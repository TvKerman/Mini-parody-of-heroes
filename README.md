# Сборка решения

```shell
  javac -cp "libs\heroes_task_lib-1.0-SNAPSHOT.jar" -d out src\programs\*.java
  jar cf jars/heroes_impl.jar -C out .
```

---

# Запуск игры
```shell
  java -jar "Heroes Battle-1.0.0.jar"
```

---

# Генерация армии противника

### Описание функции
Реализован метод `generate` для генерации армии противника на основе предоставленного списка юнитов и ограничения по очкам. Алгоритм стремится создать максимально эффективную армию, учитывая лимиты по стоимости всей армии и количеству юнитов одного типа.

### **Алгоритм работы**

### 1. **Сортировка юнитов по эффективности**
Перед формированием армии список юнитов сортируется по убыванию:
- **Первичный критерий**: коэффициент `атака / стоимость` (чем выше, тем лучше)
- **Вторичный критерий** (при равенстве первого): коэффициент `здоровье / стоимость`

Это **жадный подход**: на каждом шаге выбирается наиболее эффективный юнит в рамках оставшихся очков.

### 2. **Формирование армии**
Для каждого юнита из отсортированного списка:
- Вычисляется, сколько юнитов этого типа можно добавить, учитывая:
    - Лимит по очкам (`remainingPoints / cost`)
    - Максимальное количество юнитов одного типа (`MAX_UNIT_OF_ONE_TYPE` = 11)
- Юниты создаются с уникальными именами и случайными позициями на поле

### 3. **Генерация случайных позиций**
Метод `generateRandomPermutation` создаёт случайную перестановку чисел от `0` до `n-1` (где `n = WIDTH * DEPTH`), используя **алгоритм Фишера–Йетса (Тасовка Кнута)**. Это позволяет гарантировать отсутствие коллизий при получении координат юнитов.

## **Алгоритмическая сложность**

### **Сложность сортировки:**
- Используется `Collections.sort()` с компаратором
- В худшем случае сложность сортировки:  
  **O(m log m)**, где `m` — количество типов юнитов в `unitList`

### **Сложность формирования армии:**
- Внешний цикл по `m` типам юнитов
- Внутренний цикл добавляет до `MAX_UNIT_OF_ONE_TYPE` (константа) юнитов каждого типа
- Следовательно, сложность: **O(m * MAX_UNIT_OF_ONE_TYPE) = O(m)** (так как константа ограничена 11)

### **Сложность генерации позиций:**
- Создание перестановки: **O(n)**, где `n = WIDTH * DEPTH = 63`
- Это константная операция, так как размер поля фиксирован

### **Итоговая сложность:**
- Основные операции: сортировка (`O(m log m)`) и формирование армии (`O(m)`)
- `m =< n` (количество типов юнитов =< общего числа ячеек). При этом `n` является константой, следовательно выполнение алгоритма генерации позиций происходит за константное количество операций и не влияет на сложность всего алгоритма генерации армии.
- Сортировка и формирование армии происходит последовательно (вначале сортировка, потом формирование). 


**Итоговая сложность: `O(m log m)`**

---

# Симуляция боя (метод simulate)

## Описание функции

Метод `simulate` реализует пошаговую симуляцию сражения между армией игрока и армией компьютера. Бой происходит по раундам до полного уничтожения одной из армий.

### Алгоритм работы:
1. **Подготовительный этап**: сортировка юнитов в каждой армии по убыванию атаки
2. **Начало раунда**: Инициализация итераторов для последовательного прохода по армиям игрока и компьютера.
3. **Поочередные ходы**: юниты атакуют по очереди, начиная с самых сильных, с чередованием сторон.
4. **Удаление погибших**: в конце раунда удаляются все погибшие юниты из исходной очереди с сохранением порядка списков.
5. **Конец раунда**: проверка наличия живых юнитов в обеих армиях

### Особенности реализации:
- **Единоразовая сортировка по убыванию атаки**: сортировка по убыванию атаки юнитов для определения очередности хода происходит один раз, так как в условии не сказано об изменении параметра атаки по ходу игры, следовательно, достаточно один раз установить порядок юнитов, а затем поддерживать порядок при удалении мертвых юнитов.
- **Чередование ходов**: в каждом микро-раунде сначала ходит юнит игрока, затем компьютера. Если армия одного из игроков становится меньше армии противника, такой порядок соблюдается пока не походят все юниты игрока, а затем по порядку выполняют свои ходы оставшиеся юниты противника. (Порядок действий в данной ситуации не указан в задании)
- **Ленивое удаление**: погибшие юниты удаляются только в конце раунда, для оптимизации процесса удаления. Удаление юнитов не меняет порядок оставшихся юнитов.
- **Проверка состояния**: перед выполнением действия юнита проверяется, жив ли текущий юнит

## **Алгоритмическая сложность**

Сортировка списком с функцией-предикатом осуществляется за **`O(n log n)`**, где `n` - количество юнитов в одной армии. Сортируются два списка по очереди.

1. **Проход по юнитам для атак**:
    - Проход по всем живым юнитам обеих армий
    - Сложность: **`O(k)`**, где `k` - количество живых юнитов в армии.

2. **Удаление погибших юнитов**:
    - Используется `removeIf()` с предикатом
    - Сложность: **`O(k)`** для каждой армии

**Итоговая сложность: ``O(n log n + r * k)``, где `r` - количество раундов. При этом `r << n` и `k =< n`**

---

# Отбор целей для атаки (метод getSuitableUnits)

### Описание функции
Метод определяет доступные для атаки цели с использованием **алгоритма Z-буфера**. В каждой колонке поля (21 * 3 поле, колонкой именуется 1 * 3 клетки) выбирается один живой юнит в зависимости от направления атаки (атакует армия игрока или компьютера).

### Ключевая логика:

За основу алгоритма использована идея Z-буфера, с помощью которого определяются юниты, которые открыты для атаки (находятся на переднем крае армии в сторону противника).
Z-буфер имеет фиксированный размер в ширину доступного для расстановки армии поля (21), и представляет из себя массив ссылок на юниты, доступные для атаки.
Индекс буфера указывает на номер колонки (от 0 до 20) поля армии. Если элемент буфера хранит в себе `null` - это означает что в колонке с индексом этого элемента отсутствует юнит для атаки, иначе - ссылка на юнит для атаки в данной колонке (Так же при добавлении юнита в буфер проверяется, что юнит "жив").
Из ссылок на существующие юниты из буфера формируется список целей для атаки. (`null` ссылки игнорируются)

## **Алгоритмическая сложность**

1. Для заполнения z-buffer необходимо пройтись по всему списку юнитов армии для атаки:
   - Сложность: `O(n)`, где `n` - количество юнитов в атакуемой армии.
2. Формирование финального списка целей:
   - Сложность: `O(BUFFER_SIZE)`, где `BUFFER_SIZE = 21`. Константная сложность не учитывается в итоговой оценке сложности алгоритма.

**Итоговая сложность: `O(n)`**

---

# Поиск кратчайшего пути (метод getTargetPath)

Реализован алгоритм поиска кратчайшего пути для юнита на сетке размером 27×21 с препятствиями (другими юнитами). Решение учитывает возможность движения в 8 направлениях и оптимизировано по скорости работы.

### **Алгоритм A* (A-star) с эвристикой Чебышева**

- **Основной алгоритм**: A* для поиска кратчайшего пути на взвешенном графе
- **Эвристическая функция**: Расстояние Чебышева (`10 * max(|dx|, |dy|)`)
- **Стоимости перемещения**:
    - Ортогональные ходы (вверх/вниз/влево/вправо): 10 единиц
    - Диагональные ходы: 14 единиц (√2 ≈ 1.414)

### **Вспомогательные структуры данных**
- **PriorityQueue** для открытого множества (min-heap)
- **HashMap** для хранения g-scores и f-scores
- **HashSet** для отслеживания занятых клеток
- **Список смежности через DIRECTIONS** для 8 направлений движения

## Алгоритмическая сложность

**Сложность в худшем случае**: **`O(W·H log W·H)`**

Однако в данном случае поле лишено сложных препятствий и представляет собой открытое пространство (единственные препятствия это обход других юнитов, которые могут быть на пути. Только 6/27 (22.2% ) части поля могут составлять юниты при полном заполнении доступной части поля(21 * 3 и 21 * 3 для двух армий)). Поэтому **A'*'** алгоритму редко нужно искать обходные пути. 
Чаще всего это почти прямой путь, что значительно ускоряет работу. Худший же случай может наблюдаться лишь в полноценном лабиринте.

В данном случае худший случай невозможен ввиду параметров поля. Чаще всего будет происходить средний случай или лучший случай.
- Средний случай: **`O(k log k)`**, где `k << W * H`
- Лучший случай: **`O(l log l)`**, где `l` - длина пути.

**Итоговая сложность: `O(k log k)`**



